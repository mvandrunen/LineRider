<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Target Rider</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: #0f172a;
      color: #e5e7eb;
    }

    .top-bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 1rem;
      background: linear-gradient(to right, #020617, #0f172a);
      border-bottom: 1px solid rgba(148, 163, 184, 0.35);
      box-shadow: 0 8px 20px rgba(15, 23, 42, 0.8);
      z-index: 10;
    }

    .title {
      font-weight: 600;
      letter-spacing: 0.04em;
      font-size: 0.95rem;
      text-transform: uppercase;
      color: #f9fafb;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
    }

    button {
      border: none;
      padding: 0.35rem 0.8rem;
      border-radius: 999px;
      font-size: 0.8rem;
      cursor: pointer;
      background: #1f2937;
      color: #f9fafb;
      border: 1px solid rgba(156, 163, 175, 0.5);
      transition: background 0.15s ease, transform 0.05s ease, box-shadow 0.15s ease;
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }

    button:hover {
      background: #111827;
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.7);
      transform: translateY(-1px);
    }

    button:active {
      transform: translateY(0);
      box-shadow: none;
    }

    button.primary {
      background: #22c55e;
      border-color: #16a34a;
      color: #052e16;
      font-weight: 600;
    }

    button.primary:hover {
      background: #16a34a;
      box-shadow: 0 4px 12px rgba(21, 128, 61, 0.7);
    }

    #levelLabel {
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.7);
      color: #e5e7eb;
    }

    #statusLabel {
      min-width: 120px;
      text-align: right;
      color: #a5b4fc;
      font-weight: 500;
    }

    #gameCanvas {
      flex: 1;
      display: block;
      background: radial-gradient(circle at 20% 0%, #1e293b, #020617 55%);
      cursor: crosshair;
    }

    .hint-strip {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      padding: 0.3rem 0.8rem;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.6);
      color: #9ca3af;
      font-size: 0.75rem;
      pointer-events: none;
      backdrop-filter: blur(12px);
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div class="top-bar">
    <div class="title">Target Rider ¬∑ Prototype</div>
    <div class="controls">
      <button id="playBtn" class="primary">‚ñ∂ Play</button>
      <button id="clearTrackBtn">‚úèÔ∏è Clear Track</button>
      <button id="newTargetsBtn">üéØ New Targets</button>
      <span id="levelLabel">Level 1</span>
      <span id="statusLabel"></span>
    </div>
  </div>

  <canvas id="gameCanvas"></canvas>
  <div class="hint-strip">
    Draw a track with your mouse, then press ‚ÄúPlay‚Äù to try to hit every target.
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const playBtn = document.getElementById('playBtn');
    const clearTrackBtn = document.getElementById('clearTrackBtn');
    const newTargetsBtn = document.getElementById('newTargetsBtn');
    const levelLabel = document.getElementById('levelLabel');
    const statusLabel = document.getElementById('statusLabel');

    // --- Layout / sizing ---
    function resizeCanvasOnce() {
      canvas.width = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }

    window.addEventListener('load', resizeCanvasOnce);
    window.addEventListener('resize', () => {
      // Note: resizing the window does not rescale existing points/targets.
      // If you drastically resize, a refresh is easiest.
      resizeCanvasOnce();
    });

    // --- Game state ---
    let mode = 'draw'; // 'draw' | 'play'
    let level = 1;

    let points = [];   // [{x,y}, ...] track polyline
    let targets = [];  // [{x,y,radius,hit}, ...]

    let isDrawing = false;

    let rider = null;  // {segIndex, t, speed, x, y}
    let lastTime = 0;

    // --- Track drawing ---
    function getMousePos(evt) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: evt.clientX - rect.left,
        y: evt.clientY - rect.top
      };
    }

    canvas.addEventListener('mousedown', (evt) => {
      if (mode !== 'draw') return;
      isDrawing = true;
      const pos = getMousePos(evt);
      if (points.length === 0) {
        points.push(pos);
      } else {
        points.push(pos);
      }
    });

    canvas.addEventListener('mousemove', (evt) => {
      if (!isDrawing || mode !== 'draw') return;
      const pos = getMousePos(evt);
      const last = points[points.length - 1];
      if (!last || Math.hypot(pos.x - last.x, pos.y - last.y) > 4) {
        points.push(pos);
      }
    });

    canvas.addEventListener('mouseup', () => {
      isDrawing = false;
    });

    canvas.addEventListener('mouseleave', () => {
      isDrawing = false;
    });

    // --- Targets / difficulty scaling ---
    function generateTargets(forLevel) {
      // Number of targets grows with level
      const n = 2 + forLevel; // Level 1 => 3, Level 2 => 4, etc.

      // Cap difficulty scaling at level 10
      const difficulty = Math.min(forLevel, 10);

      // Target radius shrinks as difficulty increases
      const maxRadius = 22;
      const minRadius = 9;
      const radius =
        maxRadius -
        (maxRadius - minRadius) * ((difficulty - 1) / 9); // level 1 ~ max, level 10 ~ min

      // Margin from edges shrinks with difficulty, so higher levels push targets closer to edges
      const baseMargin = 90;
      const minMargin = 25;
      const margin =
        baseMargin -
        (baseMargin - minMargin) * ((difficulty - 1) / 9);

      targets = [];

      for (let i = 0; i < n; i++) {
        let x, y;
        let attempts = 0;

        while (true) {
          attempts++;

          if (difficulty <= 3) {
            // Early levels: central "safe" band
            x = canvas.width * 0.2 + Math.random() * canvas.width * 0.6;
            y = canvas.height * 0.2 + Math.random() * canvas.height * 0.6;
          } else if (difficulty <= 6) {
            // Mid levels: anywhere, but with a margin
            x = margin + Math.random() * (canvas.width - margin * 2);
            y = margin + Math.random() * (canvas.height - margin * 2);
          } else {
            // High levels: bias towards edges/corners
            const edge = Math.floor(Math.random() * 4);
            switch (edge) {
              case 0: // top band
                x = margin + Math.random() * (canvas.width - margin * 2);
                y = margin + Math.random() * (canvas.height * 0.25);
                break;
              case 1: // bottom band
                x = margin + Math.random() * (canvas.width - margin * 2);
                y =
                  canvas.height -
                  margin -
                  Math.random() * (canvas.height * 0.25);
                break;
              case 2: // left band
                x = margin + Math.random() * (canvas.width * 0.25);
                y = margin + Math.random() * (canvas.height - margin * 2);
                break;
              case 3: // right band
                x =
                  canvas.width -
                  margin -
                  Math.random() * (canvas.width * 0.25);
                y = margin + Math.random() * (canvas.height - margin * 2);
                break;
            }
          }

          // Avoid stacking targets on top of each other
          const tooClose = targets.some(
            (t) =>
              Math.hypot(t.x - x, t.y - y) < t.radius + radius + 10
          );

          if (!tooClose || attempts > 20) {
            targets.push({
              x,
              y,
              radius,
              hit: false
            });
            break;
          }
        }
      }
    }

    function allTargetsHit() {
      return targets.length > 0 && targets.every(t => t.hit);
    }

    function setStatus(text, highlight = false) {
      statusLabel.textContent = text || '';
      statusLabel.style.color = highlight ? '#4ade80' : '#a5b4fc';
    }

    function startLevel(newLevel) {
      level = newLevel;
      levelLabel.textContent = `Level ${level}`;
      generateTargets(level);
      rider = null;
      mode = 'draw';
      setStatus('');
    }

    function handleLevelComplete() {
      setStatus('Level complete!', true);
      const currentLevel = level;
      setTimeout(() => {
        if (level === currentLevel) {
          startLevel(level + 1);
        }
      }, 800);
    }

    // --- Rider / movement ---
    function startRun() {
      if (points.length < 2) {
        setStatus('Draw a track first.');
        return;
      }
      rider = {
        segIndex: 0,
        t: 0,
        speed: 220, // px/sec approx
        x: points[0].x,
        y: points[0].y
      };
      mode = 'play';
      setStatus('Running...');
    }

    function updateRider(dtSeconds) {
      if (!rider || points.length < 2) return;

      let remainingDist = rider.speed * dtSeconds;

      while (remainingDist > 0 && rider.segIndex < points.length - 1) {
        const p0 = points[rider.segIndex];
        const p1 = points[rider.segIndex + 1];
        const dx = p1.x - p0.x;
        const dy = p1.y - p0.y;
        const segLen = Math.hypot(dx, dy) || 1e-6;

        const distOnSeg = segLen * (1 - rider.t);
        if (remainingDist < distOnSeg) {
          const advanceT = remainingDist / segLen;
          rider.t += advanceT;
          remainingDist = 0;
        } else {
          remainingDist -= distOnSeg;
          rider.segIndex++;
          rider.t = 0;
        }
      }

      if (rider.segIndex >= points.length - 1) {
        const lastPoint = points[points.length - 1];
        rider.x = lastPoint.x;
        rider.y = lastPoint.y;
        mode = 'draw';
        setStatus('Run finished.');
        return;
      }

      const p0 = points[rider.segIndex];
      const p1 = points[rider.segIndex + 1];
      rider.x = p0.x + (p1.x - p0.x) * rider.t;
      rider.y = p0.y + (p1.y - p0.y) * rider.t;

      // Check target collisions
      for (const target of targets) {
        if (target.hit) continue;
        const dx = rider.x - target.x;
        const dy = rider.y - target.y;
        const dist = Math.hypot(dx, dy);
        if (dist <= target.radius + 3) {
          target.hit = true;
        }
      }

      if (allTargetsHit()) {
        mode = 'draw';
        handleLevelComplete();
      }
    }

    // --- Rendering ---
    function drawTrack() {
      if (points.length < 2) return;
      ctx.lineWidth = 3;
      ctx.strokeStyle = '#e5e7eb';
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.stroke();
    }

    function drawTargets() {
      for (const target of targets) {
        ctx.beginPath();
        ctx.arc(target.x, target.y, target.radius, 0, Math.PI * 2);
        const gradient = ctx.createRadialGradient(
          target.x, target.y, 0,
          target.x, target.y, target.radius
        );
        if (target.hit) {
          gradient.addColorStop(0, '#bbf7d0');
          gradient.addColorStop(1, '#22c55e');
        } else {
          gradient.addColorStop(0, '#fee2e2');
          gradient.addColorStop(1, '#ef4444');
        }
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.lineWidth = 2;
        ctx.strokeStyle = target.hit ? '#166534' : '#7f1d1d';
        ctx.stroke();

        ctx.beginPath();
        ctx.arc(target.x, target.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = target.hit ? '#052e16' : '#7f1d1d';
        ctx.fill();
      }
    }

    function drawRider() {
      if (!rider) return;
      ctx.beginPath();
      ctx.arc(rider.x, rider.y, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#38bdf8';
      ctx.fill();

      ctx.save();
      ctx.shadowColor = '#38bdf8';
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(rider.x, rider.y, 5, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(56, 189, 248, 0.4)';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    function drawBackground() {
      const spacing = 40;
      ctx.lineWidth = 0.5;
      ctx.strokeStyle = 'rgba(148, 163, 184, 0.15)';

      ctx.beginPath();
      for (let x = 0; x < canvas.width; x += spacing) {
        ctx.moveTo(x + 0.5, 0);
        ctx.lineTo(x + 0.5, canvas.height);
      }
      for (let y = 0; y < canvas.height; y += spacing) {
        ctx.moveTo(0, y + 0.5);
        ctx.lineTo(canvas.width, y + 0.5);
      }
      ctx.stroke();
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBackground();
      drawTrack();
      drawTargets();
      drawRider();
    }

    // --- Main loop ---
    function loop(timestamp) {
      const dt = lastTime ? (timestamp - lastTime) / 1000 : 0;
      lastTime = timestamp;

      if (mode === 'play' && rider) {
        updateRider(dt);
      }

      render();
      requestAnimationFrame(loop);
    }

    // --- UI events ---
    playBtn.addEventListener('click', () => {
      startRun();
    });

    clearTrackBtn.addEventListener('click', () => {
      points = [];
      rider = null;
      mode = 'draw';
      setStatus('');
    });

    newTargetsBtn.addEventListener('click', () => {
      generateTargets(level);
      setStatus('New targets created.');
    });

    // --- Initialize ---
    window.addEventListener('load', () => {
      resizeCanvasOnce();
      startLevel(1);
      requestAnimationFrame(loop);
    });
  </script>
</body>
</html>
